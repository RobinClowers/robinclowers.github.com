---
layout: post
title: "Stored Procedures, a Best Practice?"
date: 2008-06-09T18:11:00-07:00
comments: false
categories:
 - Software Development
 - Asp.net
 - Linq
---

<div class='post'>
<p>I just saw <a href="http://www.blogger.com/profile/05516602905783627586">merlin981</a>'s <a href="http://www.blogger.com/comment.g?blogID=4214922889450630344&amp;postID=2482102627266714910" target="_blank">comment</a> on my LINQ to SQL post, thanks for taking time to leave it!&#160; That said, I think the term &quot;Best Practice&quot; is something of a misnomer here.&#160; There has been <a href="http://weblogs.asp.net/fbouma/archive/2003/11/18/38178.aspx" target="_blank">much</a> <a href="http://weblogs.asp.net/rhoward/archive/2003/11/17/38095.aspx" target="_blank">written</a> on <a href="http://codebetter.com/blogs/eric.wise/archive/2006/05/24/145393.aspx" target="_blank">both</a>&#160;<a href="http://nhibernate.codebetter.com/blogs/jeremy.miller/archive/2005/07/06/130094.aspx">sides</a> of this debate.&#160; One thing is for sure, though, a parameterized query is compiled just like a stored procedure on SQL Sever version 7.0 and on.&#160; From <a href="http://weblogs.asp.net/fbouma/" target="_blank">Frans Bouma's blog</a>, I found this <a href="http://msdn.microsoft.com/en-us/library/aa174792.aspx" target="_blank">article</a> in the SQL Server's Books Online:</p>  <blockquote>   <p>SQL Server 2000 and SQL Server version 7.0 incorporate a number of changes to statement processing that extend many of the performance benefits of stored procedures to all SQL statements. SQL Server 2000 and SQL Server 7.0 do not save a partially compiled plan for stored procedures when they are created. A stored procedure is compiled at execution time, like any other Transact-SQL statement. SQL Server 2000 and SQL Server 7.0 retain execution plans for all SQL statements in the procedure cache, not just stored procedure execution plans. </p> </blockquote>  <p>So I think it is clear that sprocs will not be significantly faster than ad hoc SQL for simple cases.&#160; This is not to say that you should never use sprocs, on the contrary, there are situations where sprocs will be the only good solution (for instance, complex data manipulation that requires temporary tables). The point is that using an ORM can make development easier by allowing you to ignore the SQL for the majority of cases.&#160; If you see that parts of your application are slow, then you can fix that. </p>  <p>Merlin also mentioned that running queries directly against tables uses deferred execution like it is a bad thing.&#160; Deferred execution is what allows LINQ to work at all, and can improve performance in many scenarios.&#160; Of course, like any tool, it can get you into trouble if you don't understand it.</p>  </div>
<h2>Comments</h2>
<div class='comments'>
<div class='comment'>
<div class='author'>Robin Clowers</div>
<div class='content'>
Hi again merlin, it seems like you may be misunderstanding how Linq to Sql uses deferred execution, so I posted an <A HREF="http://robinclowers.blogspot.com/2008/06/deferred-execution-in-linq-to-sql.html" REL="nofollow">explaination</A> of it.</div>
</div>
<div class='comment'>
<div class='author'>merlin981</div>
<div class='content'>
Thank you for the response. I concede you are correct that stored procedures are not pre-compiled in SQL Server 2000 and 2005. This is definitely an under-discussed change from previous versions.<BR/><BR/>However, I do still believe stored procedures are better, if for no other reason than security. First, for the added layer of security from SQL injection attacks. Second, from the added layer of internal security (you can grant execute permission to the IIS user for stored procedures, but deny execute/insert/delete on all other SQL commands).<BR/><BR/>Regarding deferred execution, I can see it as a good thing in a limited number of scenarios. The problem with deferred execution is that developers (especially ones new to LINQ), are accustomed to knowing that when they have a List or other IENumerable/IQueryable object, the data is already there. However, with deferred execution, the data is not "there" until you request that particular element. Also, especially with SQL, the element can change before you make the request for it.<BR/><BR/>The majority of the time, the developer wants (and probably needs) the data to be there immediately. Without properly understanding deferred execution, the developer could think that his IQueryable object is fully populated, when it is not.<BR/><BR/>There is also a performance penalty, in my opinion, for deferred execution on LINQ to SQL. The problem comes when you iterate through the list; you are constantly querying the database. Constantly requesting one row at a time can have serious consequences on a production database that services several hundred users per minute. This is another advantage of stored procedures (for LINQ to SQL), because the sproc forces the database to return all the data back to LINQ immediately. In this way, regardless of deferred execution, the developer can be assured that a) he/she has only queried the database once, and b) all the data is available and will <B>not</B> change during the iteration of the data.<BR/><BR/>Thank you for this interesting conversation, Robin. The research was fun and educational.</div>
</div>
</div>
